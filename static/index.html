<!doctype html>
<html lang="zh-Hant" class="light">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>網球比賽分析助手</title>

  <!-- 字體 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;700&display=swap">
  <link rel="stylesheet" href="static/index.css?v=005" />
</head>

<body class="light">
  <!-- Header：兩個獨立玻璃塊 -->
  <header>
    <div class="glass-base header-chip">
      網球比賽分析助手
    </div>
    <button id="themeToggle" class="glass-base theme-toggle">
      <div class="ts-track">
        <div class="ts-sky ts-sky-day"></div>
        <div class="ts-sky ts-sky-night"></div>

        <div class="ts-stars"></div>
        <div class="ts-clouds ts-clouds-front"></div>
        <div class="ts-clouds ts-clouds-back"></div>
      </div>

      <div class="ts-orb">
        <div class="ts-orb-inner"></div>
      </div>
    </button>
  </header>

  <!-- 主內容 -->
  <div class="main">
    <!-- LLM 卡 -->
    <div class="glass-base llm-card">
      <div id="chat"></div>
      <div class="composer">
        <textarea id="query" placeholder="輸入你的問題..."></textarea>
        <button class="send-btn" id="sendBtn" disabled>送出</button>
      </div>
    </div>

    <!-- 右側：控制卡 + 影片卡 -->
    <div class="right-col">
      <!-- 控制卡 -->
      <div class="glass-base control-card">
        <div class="control-row">
          <input id="file" type="file" accept="video/*" style="display:none;">
          <button class="btn btn-green" id="analyzeBtn" disabled>跑 YOLO 分析</button>
          <div class="progress-bar-wrap" id="progressContainer">
            <div class="progress-bar" id="progressBar"></div>
          </div>
        </div>

        <div id="status">請先上傳影片</div>

        <div id="videoInfo"></div>

        <div class="frame-sync">
          <span style="opacity:.7;">同步微調：</span>
          <button id="btnPrevFrame" class="sync-btn">-1 幀</button>
          <span id="frameOffsetDisplay" style="min-width:26px;text-align:center;">0</span>
          <button id="btnNextFrame" class="sync-btn">+1 幀</button>
        </div>
      </div>

      <!-- 影片卡 -->
      <div class="glass-base video-card">
        <div class="video-wrapper" id="dropZone">
          <div id="videoPlaceholder">
            <img src="/static/update.svg" alt="上傳圖示">
            <div>點擊新增或拖曳影片檔案到此區塊</div>
            <button id="videoUploadBtn"></button>
          </div>
          <video id="videoPlayer" controls></video>
          <canvas id="overlay"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ========= 主題切換 ========= */
    const body = document.body;
    document.getElementById("themeToggle").onclick = () => {
      if (body.classList.contains("light")) {
        body.classList.remove("light");
        body.classList.add("dark");
      } else {
        body.classList.remove("dark");
        body.classList.add("light");
      }
    };

    /* ========= 共用 DOM ========= */
    const $ = (id) => document.getElementById(id);
    const chatEl = $("chat");
    const fileEl = $("file");
    const videoUploadBtn = $("videoUploadBtn");
    const videoInfoEl = $("videoInfo");
    const queryEl = $("query");
    const sendBtn = $("sendBtn");
    const statusEl = $("status");
    const analyzeBtn = $("analyzeBtn");
    const videoEl = $("videoPlayer");
    const canvasEl = $("overlay");
    const ctx = canvasEl.getContext("2d");
    const wrapperEl = document.getElementById("dropZone");
    const btnPrev = $("btnPrevFrame");
    const btnNext = $("btnNextFrame");
    const offsetDisplay = $("frameOffsetDisplay");
    const progressContainer = $("progressContainer");
    const progressBar = $("progressBar");
    const placeholderEl = $("videoPlaceholder");

    const SKELETON_LINKS = [
      [5, 6], [5, 11], [6, 12], [11, 12], [5, 7], [7, 9],
      [6, 8], [8, 10], [11, 13], [13, 15], [12, 14], [14, 16]
    ];

    let sessionId = null;
    let videoMeta = null;
    let localVideoUrl = null;
    let ballTracks = [];
    let poses = [];
    let tracksByFrame = {};
    let posesByFrame = {};
    let detectionReady = false;
    let frameOffset = 0;
    let rafId = null;
    let pollInterval = null;
    let analysisCompleted = false;

    /* ========== Chat 工具 ========== */
    function appendMessage(role, text) {
      const row = document.createElement("div");
      row.className = `msg-row ${role}`;
      const bubble = document.createElement("div");
      bubble.className = `bubble ${role}`;
      bubble.textContent = text;
      row.appendChild(bubble);
      chatEl.appendChild(row);
      chatEl.scrollTop = chatEl.scrollHeight;
      return bubble;
    }

    function setBusy(isBusy) {
      sendBtn.disabled = isBusy || !sessionId;
      // 上傳在分析完成後鎖死，這裡只在尚未完成時受 busy 影響
      if (!analysisCompleted) {
        videoUploadBtn.disabled = isBusy;
      }
      if (!analysisCompleted) {
        analyzeBtn.disabled = isBusy || !sessionId;
      }
      if (!sessionId) {
        statusEl.textContent = "請先上傳影片";
      } else if (isBusy) {
        statusEl.textContent = "處理中...";
      }
      // 如果不是 busy 且有其他訊息，就保持原本 status（不再顯示「可以開始提問」）
    }

    /* ========== Canvas / Overlay ========== */
    function syncCanvasSize() {
      if (!videoEl.videoWidth || !videoEl.videoHeight) return;
      canvasEl.width = videoEl.videoWidth;
      canvasEl.height = videoEl.videoHeight;
      drawOverlay();
    }

    function buildFrameMaps() {
      tracksByFrame = {};
      ballTracks.forEach((b) => {
        const f = b.frame;
        if (!tracksByFrame[f]) tracksByFrame[f] = [];
        tracksByFrame[f].push(b);
      });

      posesByFrame = {};
      poses.forEach((p) => {
        const f = p.frame;
        if (!posesByFrame[f]) posesByFrame[f] = [];
        posesByFrame[f].push(p);
      });
    }

    function drawOverlay() {
      const vw = videoEl.videoWidth;
      const vh = videoEl.videoHeight;
      const cw = wrapperEl.clientWidth;
      const ch = wrapperEl.clientHeight;

      ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
      if (!detectionReady || !vw || !vh || !cw || !ch) return;

      // 計算 object-fit: contain 實際顯示尺寸
      const videoRatio = vw / vh;
      const containerRatio = cw / ch;

      let renderW, renderH;
      if (videoRatio > containerRatio) {
        renderW = cw;
        renderH = cw / videoRatio;
      } else {
        renderH = ch;
        renderW = ch * videoRatio;
      }

      const xOffset = (cw - renderW) / 2;
      const yOffset = (ch - renderH) / 2;
      const scale = renderW / vw;

      ctx.save();
      ctx.translate(xOffset, yOffset);
      ctx.scale(scale, scale);

      const fps = (videoMeta && videoMeta.fps) || 30;
      let frameIdx = Math.round(videoEl.currentTime * fps) + frameOffset;
      if (frameIdx < 0) frameIdx = 0;

      const boxes = tracksByFrame[frameIdx] || [];
      const framePoses = posesByFrame[frameIdx] || [];

      ctx.lineWidth = 3 / scale;
      ctx.strokeStyle = "#facc15";

      boxes.forEach((b) => {
        ctx.strokeRect(b.x1, b.y1, b.x2 - b.x1, b.y2 - b.y1);
      });

      framePoses.forEach((p) => {
        const kps = p.keypoints || [];
        ctx.fillStyle = "#22c55e";
        ctx.strokeStyle = "#22c55e";
        ctx.lineWidth = 3 / scale;

        kps.forEach(([x, y, conf]) => {
          if (conf < 0.3) return;
          ctx.beginPath();
          ctx.arc(x, y, 6 / scale, 0, Math.PI * 2);
          ctx.fill();
        });

        SKELETON_LINKS.forEach(([i, j]) => {
          const a = kps[i];
          const b = kps[j];
          if (!a || !b) return;
          if (a[2] < 0.3 || b[2] < 0.3) return;
          ctx.beginPath();
          ctx.moveTo(a[0], a[1]);
          ctx.lineTo(b[0], b[1]);
          ctx.stroke();
        });
      });

      ctx.restore();
    }

    videoEl.addEventListener("loadedmetadata", syncCanvasSize);
    window.addEventListener("resize", syncCanvasSize);

    function startLoop() {
      if (rafId) cancelAnimationFrame(rafId);
      function loop() {
        if (!videoEl.paused && !videoEl.ended) {
          drawOverlay();
          rafId = requestAnimationFrame(loop);
        }
      }
      loop();
    }
    videoEl.addEventListener("play", startLoop);
    videoEl.addEventListener("pause", () => {
      if (rafId) cancelAnimationFrame(rafId);
      drawOverlay();
    });

    /* ========== 上傳與拖曳 ========== */

    function triggerFileSelect() {
      if (analysisCompleted) return; // YOLO 結束後鎖死
      fileEl.click();
    }

    videoUploadBtn.onclick = triggerFileSelect;
    placeholderEl.onclick = triggerFileSelect;

    fileEl.onchange = () => {
      if (fileEl.files && fileEl.files[0]) {
        handleUpload(fileEl.files[0]);
      }
    };

    // 拖曳上傳
    ["dragenter", "dragover"].forEach(evtName => {
      wrapperEl.addEventListener(evtName, (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (analysisCompleted) return;
        wrapperEl.classList.add("drop-active");
      });
    });

    ["dragleave", "drop"].forEach(evtName => {
      wrapperEl.addEventListener(evtName, (e) => {
        e.preventDefault();
        e.stopPropagation();
        wrapperEl.classList.remove("drop-active");
      });
    });

    wrapperEl.addEventListener("drop", (e) => {
      if (analysisCompleted) return;
      const dt = e.dataTransfer;
      if (!dt || !dt.files || !dt.files[0]) return;
      handleUpload(dt.files[0]);
    });

    async function handleUpload(file) {
      if (!file) return;
      setBusy(true);
      statusEl.textContent = "影片上傳中...";

      try {
        if (localVideoUrl) URL.revokeObjectURL(localVideoUrl);
        localVideoUrl = URL.createObjectURL(file);
        videoEl.src = localVideoUrl;
        placeholderEl.style.display = "none";
        videoEl.style.display = "block";

        const fd = new FormData();
        fd.append("file", file);
        const res = await fetch("/upload", {
          method: "POST",
          body: fd
        });
        const data = await res.json();
        if (!data.ok) throw new Error(data.error || "上傳失敗");

        sessionId = data.session_id;
        videoMeta = data.meta;
        detectionReady = false;
        ballTracks = [];
        poses = [];
        tracksByFrame = {};
        posesByFrame = {};
        frameOffset = 0;
        offsetDisplay.textContent = "0";

        analyzeBtn.disabled = false;
        sendBtn.disabled = false;

        const m = data.meta;
        videoInfoEl.textContent =
          `檔名：${data.filename}\n` +
          `解析度：${m.width} x ${m.height}\n` +
          `FPS：${m.fps}\n` +
          `時長：${m.duration.toFixed(2)}s`;

        statusEl.textContent = "影片上傳完成";
        appendMessage("assistant", "影片上傳完成！");
      } catch (err) {
        alert("上傳失敗：" + err.message);
        statusEl.textContent = "上傳失敗，請重試";
      } finally {
        setBusy(false);
      }
    }

    /* ========== YOLO 分析 ========== */
    analyzeBtn.onclick = async () => {
      if (!sessionId) {
        alert("請先上傳影片");
        return;
      }
      if (analysisCompleted) return;

      setBusy(true);
      analyzeBtn.disabled = true;
      progressContainer.style.display = "block";
      progressBar.style.width = "0%";
      statusEl.textContent = "準備開始分析...";

      try {
        const res = await fetch("/analyze_yolo", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ session_id: sessionId, max_frames: 1000 })
        });
        const data = await res.json();
        if (!data.ok) throw new Error(data.detail || "啟動失敗");

        pollInterval = setInterval(async () => {
          try {
            const s = await fetch(`/analyze_status/${sessionId}`);
            const st = await s.json();

            const pct = st.progress || 0;
            progressBar.style.width = pct + "%";
            statusEl.textContent = `YOLO 分析中 (${pct}%)`;

            if (st.status === "completed") {
              clearInterval(pollInterval);
              pollInterval = null;

              ballTracks = st.ball_tracks || [];
              poses = st.poses || [];
              detectionReady = true;

              buildFrameMaps();
              syncCanvasSize();

              statusEl.textContent = `分析完成：球軌跡 ${ballTracks.length}、姿態 ${poses.length}`;
              progressContainer.style.display = "none";

              // 分析完成後前端鎖死：不可再重新上傳或分析
              analysisCompleted = true;
              analyzeBtn.disabled = true;
              videoUploadBtn.disabled = true;
              btnPrev.disabled = false;
              btnNext.disabled = false;
              // drag & drop 透過 analysisCompleted flag 自然失效

              setBusy(false);
            } else if (st.status === "failed") {
              clearInterval(pollInterval);
              pollInterval = null;
              statusEl.textContent = "YOLO 分析失敗";
              progressContainer.style.display = "none";
              alert("分析失敗：" + (st.error || "未知錯誤"));
              setBusy(false);
            }
          } catch (e) {
            console.error("輪詢錯誤", e);
          }
        }, 900);

      } catch (err) {
        progressContainer.style.display = "none";
        statusEl.textContent = "啟動分析失敗";
        alert("啟動分析失敗：" + err.message);
        setBusy(false);
      }
    };

    // 同步微調
    btnPrev.onclick = () => {
      frameOffset--;
      offsetDisplay.textContent = frameOffset;
      drawOverlay();
    };
    btnNext.onclick = () => {
      frameOffset++;
      offsetDisplay.textContent = frameOffset;
      drawOverlay();
    };

    /* ========== LLM 聊天，含「思考中...」動畫 ========== */
    sendBtn.onclick = sendQuestion;
    queryEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendQuestion();
      }
    });

    let thinkingTimer = null;

    function startThinking(bubble) {
      let dots = 1;
      bubble.textContent = "思考中.";
      thinkingTimer = setInterval(() => {
        dots = (dots % 3) + 1;
        bubble.textContent = "思考中" + ".".repeat(dots);
      }, 500);
    }

    function stopThinking() {
      if (thinkingTimer) {
        clearInterval(thinkingTimer);
        thinkingTimer = null;
      }
    }

    async function sendQuestion() {
      if (!sessionId) {
        alert("請先上傳影片");
        return;
      }
      const text = queryEl.value.trim();
      if (!text) return;

      appendMessage("user", text);
      queryEl.value = "";

      const thinkingBubble = appendMessage("assistant", "");
      startThinking(thinkingBubble);

      setBusy(true);

      try {
        const res = await fetch("/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ session_id: sessionId, question: text })
        });

        if (!res.ok || !res.body) {
          stopThinking();
          thinkingBubble.textContent = "錯誤：" + (await res.text() || res.statusText);
          return;
        }

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let full = "";
        let gotChunk = false;

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) {
            if (!gotChunk) {
              gotChunk = true;
              stopThinking();
              thinkingBubble.textContent = "";
            }
            const chunkText = decoder.decode(value, { stream: true });
            full += chunkText;
            thinkingBubble.textContent = full;
            chatEl.scrollTop = chatEl.scrollHeight;
          }
        }

        if (!gotChunk) {
          // 沒有任何串流內容
          stopThinking();
          thinkingBubble.textContent = "(無回應內容)";
        }

      } catch (err) {
        stopThinking();
        thinkingBubble.textContent = "連線失敗：" + err.message;
      } finally {
        setBusy(false);
      }
    }

    // 初始狀態
    setBusy(false);
    btnPrev.disabled = true;
    btnNext.disabled = true;
  </script>
</body>

</html>