<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>網球比賽分析助手</title>
  <link rel="stylesheet" href="/static/index.css">
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>網球比賽分析助手</h1>
        <span>左邊 LLM 討論，右邊 YOLO 偵測畫面</span>
      </div>
      <span id="status">請先上傳影片</span>
    </header>

    <div class="top-panel">
      <div class="upload-row">
        <input id="file" type="file" accept="video/*" />
        <button id="uploadBtn">上傳影片</button>
        <button id="analyzeBtn" disabled>跑 YOLO 分析</button>
        <span id="uploadInfo"></span>
      </div>
      <div id="videoInfo"></div>
    </div>

    <div class="main">
      <div class="left-panel">
        <div id="chat"></div>
        <div class="composer">
          <textarea id="query" placeholder="輸入你的問題..."></textarea>
          <div class="composer-bottom">
            <div class="hint">針對同一支影片提問。</div>
            <button class="send-btn" id="sendBtn" disabled>送出</button>
          </div>
        </div>
      </div>

      <div class="right-panel">
        <div class="video-wrapper">
          <video id="videoPlayer" controls></video>
          <canvas id="overlay"></canvas>
        </div>
        <div class="right-panel-bottom">
          <div id="progressContainer">
            <div id="progressBar"></div>
          </div>
          <span id="yoloStatus">尚未執行 YOLO 分析</span>
          <div class="sync-controls">
            <span style="font-size: 12px; color: #9ca3af;">同步微調:</span>
            <button id="btnPrevFrame" class="sync-btn">-1 幀</button>
            <span id="frameOffsetDisplay" style="min-width: 20px; text-align: center; font-family: monospace;">0</span>
            <button id="btnNextFrame" class="sync-btn">+1 幀</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);
    const chatEl = $("chat");
    const fileEl = $("file");
    const uploadBtn = $("uploadBtn");
    const uploadInfoEl = $("uploadInfo");
    const videoInfoEl = $("videoInfo");
    const queryEl = $("query");
    const sendBtn = $("sendBtn");
    const statusEl = $("status");
    const analyzeBtn = $("analyzeBtn");
    const yoloStatusEl = $("yoloStatus");
    const videoEl = $("videoPlayer");
    const canvasEl = $("overlay");
    const ctx = canvasEl.getContext("2d");
    const wrapperEl = document.querySelector(".video-wrapper");
    const btnPrev = $("btnPrevFrame");
    const btnNext = $("btnNextFrame");
    const offsetDisplay = $("frameOffsetDisplay");
    
    // 進度條元件
    const progressContainer = $("progressContainer");
    const progressBar = $("progressBar");

    const SKELETON_LINKS = [[5, 6], [5, 11], [6, 12], [11, 12], [5, 7], [7, 9], [6, 8], [8, 10], [11, 13], [13, 15], [12, 14], [14, 16]];

    let sessionId = null;
    let videoMeta = null;
    let localVideoUrl = null;
    let ballTracks = [];
    let poses = [];
    let tracksByFrame = {};
    let posesByFrame = {};
    let detectionReady = false;
    let frameOffset = 0;
    let rafId = null;
    let pollInterval = null; // 輪詢計時器

    function appendMessage(role, text, meta) {
      const row = document.createElement("div"); row.className = `msg-row ${role}`;
      const bubble = document.createElement("div"); bubble.className = `bubble ${role}`;
      bubble.textContent = text; row.appendChild(bubble);
      if (meta) { const m = document.createElement("div"); m.className = "meta-text"; m.textContent = meta; row.appendChild(m); }
      chatEl.appendChild(row); chatEl.scrollTop = chatEl.scrollHeight;
    }

    function setBusy(isBusy) {
      sendBtn.disabled = isBusy || !sessionId;
      uploadBtn.disabled = isBusy;
      // 分析按鈕在忙碌時停用，除非是輪詢狀態 (後面處理)
      analyzeBtn.disabled = isBusy || !sessionId;
      statusEl.textContent = isBusy ? "處理中..." : sessionId ? "可以開始提問或執行 YOLO 分析" : "請先上傳影片";
    }

    function syncCanvasSize() {
      if (!wrapperEl || !videoEl) return;
      const vW = videoEl.videoWidth; const vH = videoEl.videoHeight;
      if (!vW || !vH) return;
      canvasEl.width = vW; canvasEl.height = vH;
      const vRect = videoEl.getBoundingClientRect(); const wRect = wrapperEl.getBoundingClientRect();
      const eRatio = vRect.width / vRect.height; const vRatio = vW / vH;
      let dW = vRect.width, dH = vRect.height, offX = 0, offY = 0;
      if (eRatio > vRatio) { dW = vRect.height * vRatio; offX = (vRect.width - dW) / 2; }
      else { dH = vRect.width / vRatio; offY = (vRect.height - dH) / 2; }
      canvasEl.style.width = `${dW}px`; canvasEl.style.height = `${dH}px`;
      canvasEl.style.left = `${vRect.left + offX - wRect.left}px`; canvasEl.style.top = `${vRect.top + offY - wRect.top}px`;
      drawOverlay();
    }

    window.addEventListener("resize", () => { syncCanvasSize(); });
    videoEl.addEventListener("loadedmetadata", () => { syncCanvasSize(); });

    btnPrev.onclick = () => { frameOffset--; offsetDisplay.textContent = frameOffset; drawOverlay(); };
    btnNext.onclick = () => { frameOffset++; offsetDisplay.textContent = frameOffset; drawOverlay(); };

    function startLoop() {
      if (rafId) cancelAnimationFrame(rafId);
      function loop() { if (!videoEl.paused && !videoEl.ended) { drawOverlay(); rafId = requestAnimationFrame(loop); } }
      loop();
    }
    videoEl.addEventListener("play", startLoop);
    videoEl.addEventListener("pause", () => { if (rafId) cancelAnimationFrame(rafId); drawOverlay(); });
    videoEl.addEventListener("seeked", drawOverlay);

    function buildFrameMaps() {
      tracksByFrame = {}; ballTracks.forEach((b) => { const f = b.frame; if (!tracksByFrame[f]) tracksByFrame[f] = []; tracksByFrame[f].push(b); });
      posesByFrame = {}; poses.forEach((p) => { const f = p.frame; if (!posesByFrame[f]) posesByFrame[f] = []; posesByFrame[f].push(p); });
    }

    function drawOverlay() {
      ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
      if (!detectionReady || !videoEl.videoWidth) return;
      const fps = (videoMeta && videoMeta.fps) || 30;
      let frameIdx = Math.round(videoEl.currentTime * fps) + frameOffset;
      if (frameIdx < 0) frameIdx = 0;
      const boxes = tracksByFrame[frameIdx] || [];
      const framePoses = posesByFrame[frameIdx] || [];
      
      ctx.lineWidth = 4; ctx.strokeStyle = "#facc15"; 
      boxes.forEach((b) => { ctx.strokeRect(b.x1, b.y1, b.x2 - b.x1, b.y2 - b.y1); });

      framePoses.forEach((p) => {
        const kps = p.keypoints || []; if (!kps.length) return;
        const pts = kps.map(([x, y, conf]) => ({ x, y, conf }));
        ctx.fillStyle = "#22c55e";
        pts.forEach((pt) => { if (pt.conf < 0.3) return; ctx.beginPath(); ctx.arc(pt.x, pt.y, 6, 0, Math.PI * 2); ctx.fill(); });
        ctx.strokeStyle = "#22c55e"; ctx.lineWidth = 4;
        SKELETON_LINKS.forEach(([i, j]) => {
          const a = pts[i]; const b = pts[j]; if (!a || !b) return; if (a.conf < 0.3 || b.conf < 0.3) return;
          ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
        });
      });
    }

    uploadBtn.onclick = async () => {
      const f = fileEl.files[0]; if (!f) { alert("請選擇影片檔"); return; }
      setBusy(true); uploadInfoEl.textContent = "上傳中..."; videoInfoEl.textContent = "";
      yoloStatusEl.textContent = "尚未執行 YOLO 分析";
      detectionReady = false; ballTracks = []; poses = []; tracksByFrame = {}; posesByFrame = {}; frameOffset = 0; offsetDisplay.textContent = "0";
      drawOverlay();
      if (localVideoUrl) URL.revokeObjectURL(localVideoUrl);
      localVideoUrl = URL.createObjectURL(f); videoEl.src = localVideoUrl;

      try {
        const fd = new FormData(); fd.append("file", f);
        const res = await fetch("/upload", { method: "POST", body: fd });
        const data = await res.json();
        if (!data.ok) throw new Error(data.error || "上傳失敗");
        sessionId = data.session_id; videoMeta = data.meta;
        uploadInfoEl.textContent = "✅ 上傳完成";
        sendBtn.disabled = false; analyzeBtn.disabled = false;
        const m = data.meta || {};
        const lines = [`檔名：${data.filename || "(未知)"}`, m.width ? `解析度：${m.width} x ${m.height}` : "", m.fps ? `FPS：${m.fps.toFixed(2)}` : "", m.duration ? `時長：${m.duration.toFixed(2)}s` : ""].filter(x=>x).join("\n");
        videoInfoEl.textContent = lines;
        appendMessage("assistant", "影片上傳完成！");
      } catch (e) { console.error(e); uploadInfoEl.textContent = "❌ 上傳失敗"; alert("上傳失敗：" + e.message); sessionId = null; sendBtn.disabled = true; analyzeBtn.disabled = true; } finally { setBusy(false); }
    };

    // --- 修改：分析按鈕邏輯 (背景任務 + 輪詢) ---
    analyzeBtn.onclick = async () => {
      if (!sessionId) { alert("請先上傳影片"); return; }
      
      // UI 狀態切換
      setBusy(true); // 鎖定其他按鈕
      analyzeBtn.disabled = true; // 鎖定自己
      yoloStatusEl.textContent = "準備開始分析...";
      progressContainer.style.display = "block";
      progressBar.style.width = "0%";

      try {
        // 1. 發送開始請求
        const res = await fetch("/analyze_yolo", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ session_id: sessionId, max_frames: 1000 }),
        });
        const data = await res.json();
        if (!data.ok) throw new Error(data.detail || "啟動失敗");

        // 2. 開始輪詢進度
        yoloStatusEl.textContent = "YOLO 分析進行中 (0%)...";
        
        pollInterval = setInterval(async () => {
          try {
            const statusRes = await fetch(`/analyze_status/${sessionId}`);
            const statusData = await statusRes.json();
            
            // 更新進度條
            const pct = statusData.progress || 0;
            progressBar.style.width = `${pct}%`;
            yoloStatusEl.textContent = `YOLO 分析進行中 (${pct}%)...`;

            if (statusData.status === "completed") {
              clearInterval(pollInterval);
              // 完成，載入數據
              ballTracks = statusData.ball_tracks || [];
              poses = statusData.poses || [];
              detectionReady = true;
              buildFrameMaps();
              syncCanvasSize();
              
              yoloStatusEl.textContent = `✅ 分析完成：球軌跡 ${ballTracks.length}，姿態 ${poses.length}。`;
              progressContainer.style.display = "none";
              setBusy(false);
            } else if (statusData.status === "failed") {
              clearInterval(pollInterval);
              yoloStatusEl.textContent = `❌ 分析失敗：${statusData.error}`;
              progressContainer.style.display = "none";
              setBusy(false);
              alert("分析失敗：" + statusData.error);
            }
          } catch (err) {
            console.error("輪詢錯誤", err);
          }
        }, 1000); // 每秒檢查一次

      } catch (e) {
        console.error(e);
        yoloStatusEl.textContent = "啟動分析失敗：" + e.message;
        progressContainer.style.display = "none";
        setBusy(false);
      }
    };

    async function sendQuestion() {
    if (!sessionId) { alert("請先上傳影片"); return; }
    const text = queryEl.value.trim();
    if (!text) { alert("請輸入問題"); return; }

    // 使用者訊息先畫出來
    appendMessage("user", text);
    queryEl.value = "";

    // 建立空的 assistant 泡泡，等等一路更新內容
    const row = document.createElement("div");
    row.className = "msg-row assistant";
    const bubble = document.createElement("div");
    bubble.className = "bubble assistant";
    bubble.textContent = ""; // 先空字串
    row.appendChild(bubble);
    chatEl.appendChild(row);
    chatEl.scrollTop = chatEl.scrollHeight;

    setBusy(true);

    try {
      const res = await fetch("/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ session_id: sessionId, question: text }),
      });

      if (!res.ok) {
        const errText = await res.text();
        bubble.textContent = "錯誤：" + (errText || res.statusText);
        return;
      }

      // 串流讀取
      const reader = res.body?.getReader();
      if (!reader) {
        // 環境不支援串流，退而求其次整包讀
        const fallbackText = await res.text();
        bubble.textContent = fallbackText || "(空)";
        return;
      }

      const decoder = new TextDecoder("utf-8");
      let done = false;
      let fullText = "";

      while (!done) {
        const { value, done: doneReading } = await reader.read();
        done = doneReading;
        if (value) {
          const chunkText = decoder.decode(value, { stream: !done });
          if (chunkText) {
            fullText += chunkText;
            bubble.textContent = fullText;
            chatEl.scrollTop = chatEl.scrollHeight;
          }
        }
      }
    } catch (e) {
      console.error(e);
      bubble.textContent = "連線失敗：" + e.message;
    } finally {
      setBusy(false);
    }
  }

  sendBtn.onclick = sendQuestion;
  queryEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      sendQuestion();
    }
  });

  setBusy(false);
</script>
</body>
</html>